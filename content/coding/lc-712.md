---
title: "LC 712 - Minimum ASCII Delete Sum for Two Strings"
date: 2026-01-10
tags: ["dp"]
weight: -3800
---

## Approach
Todays daily is a dp-like problem, and we maintain a `n+1` times `m+1` memo, and see if we want to match the current character, if not we remove either from `s1` or `s2` and proceed the dp.

This is correct but we can actually be faster using a bottom-up approach, so I rewrite the idea with bottom up approach. After consulting with AI, the reason for faster in bottom-up mainly due to (1) lower L1/L2 cahce hit due to better locality, (2) no need of function stack, (3) slightly lower branching, but there are some problems that are not favorable for using bottom up aproach such as digit-dp, tree-dp, graph-dp.

## Code-1: top-down DP
```c++
class Solution {
public:
    int m;
    int n;
    int minimumDeleteSum(string s1, string s2) {
        m = s1.size();
        n = s2.size();
        memo.assign(m+1, vector<int>(n+1, -1));
        // init base
        memo[m][n] = 0;
        int cost = 0;
        for(int i = m-1 ; i >= 0 ; --i) {
            cost += s1[i];
            memo[i][n] = cost;
        }
        cost = 0;
        for(int i = n-1 ; i >= 0 ; --i) {
            cost += s2[i];
            memo[m][i] = cost;
        }
        // dp
        return traverse(s1, s2, 0, 0);
    }

    int traverse(const string& s1, const string& s2, int idx1, int idx2) {
        int cost = INT_MAX;
        if(idx1 == m && idx2 == n) return 0;
        if(memo[idx1][idx2] != -1) return memo[idx1][idx2];
        if(s1[idx1] == s2[idx2]) {
            cost = min(cost, traverse(s1, s2, idx1+1, idx2+1));
        }
        cost = min(cost, s2[idx2] + traverse(s1, s2, idx1, idx2+1));
        cost = min(cost, s1[idx1] + traverse(s1, s2, idx1+1, idx2));
        memo[idx1][idx2] = cost;
        return cost;
    }

    vector<vector<int>> memo;
};
```

## Code-2: bottom-up DP
```c++
class Solution {
public:
    int m;
    int n;
    int minimumDeleteSum(string s1, string s2) {
        m = s1.size();
        n = s2.size();
        vector<vector<int>> memo(m, vector<int>(n, -1));

        int cost = 0;
        bool occur = false;
        for(int i = 0 ; i < m ; ++i) {
            if(s1[i] == s2[0]) occur = true;
            cost += s1[i];
            memo[i][0] = occur ? cost - s2[0] : cost + s2[0];
        }
        cost = 0;
        occur = false;
        for(int i = 0 ; i < n ; ++i) {
            if(s2[i] == s1[0]) occur = true;
            cost += s2[i];
            memo[0][i] = occur ? cost - s1[0] : cost + s1[0];
        }

        // dp
        for(int i = 1 ; i < m; ++i) {
            for(int j = 1 ; j < n ; ++j) {
                int minCost = INT_MAX;
                if(s1[i] == s2[j]) minCost = min(minCost, memo[i-1][j-1]);
                minCost = min(minCost, s2[j] + memo[i][j-1]);
                minCost = min(minCost, s1[i] + memo[i-1][j]);
                memo[i][j] = minCost;
            }
        }
        return memo[m-1][n-1];
    }
};
```
