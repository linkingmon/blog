---
title: "LC 3797 - Count Routes to Climb a Rectangular Grid"
date: 2026-01-03
tags: ["dp", "biweek-173"]
weight: -3797
---

## Approach
This is a DP like problem, and I find that we can think that when we want to calculate `ans[i][j]` on row `i` from row `i-1`, we just aggregate the previous row's `ans` within the l2 distance of `d` and we get the answer.

But the problem stats that we can jump in the same row in range `d`, so I tried to buffer the row `i-1` aggregated results to `jump`, and then try to sum up all the `jump` within distance `d`.
Originally I think that for the index `j` itself we need to count twice, since we can jump from upper row, or jump from upper row and jump to itself again. However, from the testcase it seems that jump to itself is invalid. Under this circumstance we just add up all the jumps within range `d` and we got the answer for row `i`.

During implementation I found that to find that distance for the upper row, the distance is `floor(sqrt(d*d-1))`, and this is actually `d-1` when all integer.

I submit the first version and find that got a TLE, and find that when doing aggregation from either `jump` to `ans`, or from `ans` to `jump`, the complexity is `N*N`, and this can actually be done by prefix sum, and I modify the code and submit and pass! (after this submission, the time is about 1~2 minutes left ðŸ˜‚)	 

This is the second time got 4 ACs!

## Code
```c++
class Solution {
public:
    const int mod = 1'000'000'007;
    int numberOfRoutes(vector<string>& grid, int d) {
        // int upLen = floor(sqrt(d*d-1)); // 1 -> 0, 2 -> 1
        // actually up row is alwaus d-1.
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<long long>> ans(m, vector<long long>(n, 0));
        vector<long long> jump(n, 0);
        vector<long long> pref(n, 0);
        // base case
        for(int i = 0 ; i < n ; ++i) {
            if(grid[0][i] == '.') jump[i] = 1;
            else jump[i] = 0;
        }
        pref.assign(n, 0);
        long long pSum = 0;
        for(int i = 0 ; i < n ; ++i) {
            pSum += jump[i];
            pref[i] = pSum;
        }
        // for(int i = 0 ; i < n ; ++i) {
        //     int start = max(i-d, 0);
        //     int end = min(i+d, n-1);
        //     for(int j = start ; j <= end ; ++j) {
        //         if(grid[0][i] == '.') {
        //             ans[0][i] += jump[j];
        //             ans[0][i] %= mod;
        //         }
        //     }
        // }
        for(int i = 0 ; i < n ; ++i) {
            int start = max(i-d, 0);
        int end = min(i+d, n-1);
            if(grid[0][i] == '.') {
                ans[0][i] += (pref[end] - ( start >= 1 ? pref[start-1] : 0));
                ans[0][i] %= mod;
            }
        }
        // dp
        for(int row = 1 ; row < m ; ++row) {
            jump.assign(n, 0);
            pref.assign(n, 0);
            pSum = 0;
            for(int i = 0 ; i < n ; ++i) {
                pSum += ans[row-1][i];
                pref[i] = pSum;
            }
            
            for(int i = 0 ; i < n ; ++i) {
                int start = max(i-(d-1), 0);
                int end = min(i+(d-1), n-1);
                // for(int j = start ; j <= end ; ++j) {
                //     if(grid[row][i] == '.') {
                //         jump[i] += ans[row-1][j];
                //         jump[i] %= mod;
                //     }
                // }
                if(grid[row][i] == '.') {
                    jump[i] += (pref[end] - ( start >= 1 ? pref[start-1] : 0));
                    jump[i] %= mod;
                }
            }
            // update ans.
            pref.assign(n, 0);
            pSum = 0;
            for(int i = 0 ; i < n ; ++i) {
                pSum += jump[i];
                pref[i] = pSum;
            }
            for(int i = 0 ; i < n ; ++i) {
                int start = max(i-d, 0);
                int end = min(i+d, n-1);
                // for(int j = start ; j <= end ; ++j) {
                //     if(grid[row][i] == '.') {
                //         ans[row][i] += jump[j];
                //         ans[row][i] %= mod;
                //     }
                // }
                if(grid[row][i] == '.') {
                    ans[row][i] += (pref[end] - ( start >= 1 ? pref[start-1] : 0));
                    ans[row][i] %= mod;
                }
            }
        }
        // final sum
        long long finalAns = 0;
        for(int i = 0 ; i < n ; ++i) {
            finalAns += ans[m-1][i];
            finalAns %= mod;
        }
        // for(int i = 0 ; i < m ; ++i) {
        //     for(int j = 0 ; j < n ; ++j) {
        //         cout << ans[i][j] << "  ";
        //     } cout << endl;
        // }
        return finalAns;
        
    }
};
```
